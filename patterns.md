# Паттерны проектирования (Design Patterns)

Паттерны проектирования (Design Patterns) — это общепринятые, проверенные временем решения типичных проблем проектирования программного обеспечения. Они представляют собой шаблоны для решения распространенных задач, которые могут возникнуть в процессе разработки. Паттерны помогают улучшить структуру, гибкость и читаемость кода, а также облегчают его сопровождение и расширение.

Паттерны проектирования можно разделить на три основные категории:

### 1. **Порождающие паттерны (Creational Patterns)**
Порождающие паттерны связаны с процессом создания объектов. Они позволяют создавать объекты таким образом, чтобы повысить гибкость и повторное использование кода.

- **Singleton (Одиночка)**: Гарантирует, что у класса будет только один экземпляр, и предоставляет глобальную точку доступа к нему.
- **Factory Method (Фабричный метод)**: Определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемого объекта.
- **Abstract Factory (Абстрактная фабрика)**: Предоставляет интерфейс для создания семейств связанных или зависимых объектов, не уточняя их конкретные классы.
- **Builder (Строитель)**: Позволяет пошагово создавать сложные объекты. Отделяет процесс конструирования объекта от его представления.
- **Prototype (Прототип)**: Создает новые объекты путем клонирования существующих экземпляров.

### 2. **Структурные паттерны (Structural Patterns)**
Структурные паттерны определяют, как различные объекты и классы могут быть объединены для построения более крупных структур, сохраняя при этом гибкость и эффективность.

- **Adapter (Адаптер)**: Преобразует интерфейс одного класса в интерфейс, который ожидает клиент. Позволяет классам с несовместимыми интерфейсами работать вместе.
- **Bridge (Мост)**: Разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга.
- **Composite (Компоновщик)**: Позволяет создавать древовидные структуры объектов и работать с ними, как с единичными объектами.
- **Decorator (Декоратор)**: Позволяет динамически добавлять новые поведения объектам, оборачивая их в классы-обертки.
- **Facade (Фасад)**: Предоставляет простой интерфейс к сложной системе классов или библиотеки.
- **Flyweight (Приспособленец)**: Оптимизирует работу с памятью за счет разделения общего состояния между объектами.
- **Proxy (Заместитель)**: Предоставляет замену другому объекту для контроля доступа, уменьшения затрат или добавления функциональности. Ленивая загрузка - оригинальный объет будет загружен только по запросу.

### 3. **Поведенческие паттерны (Behavioral Patterns)**
Поведенческие паттерны описывают взаимодействие между объектами и классов и то, как они обмениваются информацией.

- **Chain of Responsibility (Цепочка обязанностей)**: Передает запрос по цепочке обработчиков, где каждый обработчик решает, обрабатывать запрос или передать его дальше.
- **Command (Команда)**: Инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с другими запросами, ставить запросы в очередь или регистрировать их для отмены.
- **Interpreter (Интерпретатор)**: Определяет грамматику простого языка и интерпретирует предложения этого языка.
- **Iterator (Итератор)**: Предоставляет способ последовательного обхода элементов коллекции без раскрытия внутреннего представления коллекции.
- **Mediator (Посредник)**: Определяет объект, который инкапсулирует способ взаимодействия множества объектов, уменьшая прямые зависимости между ними.
- **Memento (Хранитель)**: Сохраняет и восстанавливает состояние объекта, не нарушая инкапсуляции.
- **Observer (Наблюдатель)**: Определяет зависимость «один ко многим» между объектами, так что при изменении состояния одного объекта, все его зависимые объекты оповещаются и обновляются.
- **State (Состояние)**: Позволяет объекту изменять свое поведение при изменении его внутреннего состояния.
- **Strategy (Стратегия)**: Определяет семейство алгоритмов, инкапсулирует их и делает взаимозаменяемыми.
- **Template Method (Шаблонный метод)**: Определяет скелет алгоритма, перекладывая детали на подклассы.
- **Visitor (Посетитель)**: Позволяет добавлять новые операции к объектам, не изменяя их классы.

### Зачем использовать паттерны проектирования?

1. **Повторное использование решений**: Паттерны предлагают готовые решения для распространенных проблем, экономя время и усилия разработчиков.
2. **Улучшение структуры кода**: Паттерны помогают организовать код так, чтобы он был более гибким, модульным и легким для сопровождения.
3. **Общение в команде**: Использование общепринятых паттернов упрощает коммуникацию между разработчиками, так как паттерны являются общим языком, который понимают все.

### Заключение

Паттерны проектирования — это мощный инструмент в арсенале разработчика, который помогает решать распространенные задачи более эффективным и элегантным способом. Использование паттернов делает код более устойчивым к изменениям, улучшает его читаемость и облегчает командную работу.
