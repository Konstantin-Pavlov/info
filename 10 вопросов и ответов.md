### Java Collections

**1. Какова временная сложность операций в `HashMap`?**
- Операции вставки, удаления и поиска в среднем выполняются за **`O(1)`** благодаря хэш-таблице. Однако в худшем случае, когда все ключи попадают в одно и то же ведро (коллизии), сложность может возрасти до **`O(n)`**. В Java 8 и выше для разрешения коллизий используются не списки, а сбалансированные деревья (красно-черные деревья), что улучшает сложность в худшем случае до **`O(log n)`**.

**2. Чем `LinkedHashSet` отличается от `HashSet`?**
- **`HashSet`** не гарантирует порядка элементов, так как он основан на хэш-таблицах. **`LinkedHashSet`** наследует от `HashSet`, но дополнительно сохраняет порядок вставки элементов благодаря двусвязному списку. В итоге все операции (вставка, удаление, проверка на наличие) выполняются за **`O(1)`** в среднем, но при этом сохраняется порядок.

**3. Чем отличается `ArrayList` от `LinkedList`?**
- **`ArrayList`** использует массив для хранения элементов, что обеспечивает быструю индексацию (`O(1)`) и медленное добавление/удаление в середине или начале списка (`O(n)`).
- **`LinkedList`** основан на двусвязном списке, что делает операции вставки и удаления быстрыми (`O(1)` для добавления в начало и конец), но медленной является индексация (`O(n)`).

**4. Какова временная сложность основных операций в `TreeSet`?**
- `TreeSet` основан на сбалансированном бинарном дереве (обычно красно-черном дереве), что делает сложность всех операций (вставка, удаление, проверка на наличие) **`O(log n)`**. В отличие от `HashSet`, `TreeSet` поддерживает элементы в отсортированном порядке.

**5. Как работает `PriorityQueue` и какова ее сложность?**
- `PriorityQueue` — это очередь с приоритетом, которая основана на двоичной куче. Каждый раз, когда элемент добавляется, очередь автоматически поддерживает его позицию в соответствии с естественным порядком или компаратором. Добавление элемента и удаление минимального элемента имеют сложность **`O(log n)`**, а доступ к минимальному элементу — **`O(1)`**.

**6. Как работает `ConcurrentHashMap`?**
- `ConcurrentHashMap` — это потокобезопасная реализация `HashMap`, которая позволяет множеству потоков параллельно читать и записывать данные без блокировки всей карты. Он разбивает внутреннюю структуру на сегменты и использует сегментную блокировку (`lock striping`), что позволяет нескольким потокам одновременно изменять разные части карты. В Java 8 и выше он был оптимизирован, заменив сегменты на более сложные структуры, такие как `CAS` (Compare-And-Swap) и `synchronized` блоки для увеличения производительности.

**7. Какова Big O сложность основных операций в `ArrayList`?**
- Вставка элемента в конец списка — `O(1)` (амортизированная).
- Доступ по индексу — `O(1)`.
- Вставка или удаление элемента из середины — `O(n)`, так как нужно смещать элементы.
- Поиск элемента (поиск по значению) — `O(n)`.

**8. Чем отличается `HashSet` от `TreeSet`?**
- **`HashSet`** основан на хэш-таблицах и обеспечивает добавление, удаление и проверку на наличие элемента за `O(1)` в среднем случае. Элементы не упорядочены.
- **`TreeSet`** основан на сбалансированных бинарных деревьях (обычно красно-черное дерево), поддерживает элементы в отсортированном порядке и имеет сложность всех основных операций `O(log n)`.

**9. Что такое `LinkedHashMap` и как она работает?**
- `LinkedHashMap` является расширением `HashMap`, но в отличие от последней, сохраняет порядок вставки элементов (или порядок доступа, если включена соответствующая опция). Внутри она использует двусвязный список для сохранения порядка и хэш-таблицу для быстрого доступа к элементам. Операции по добавлению, удалению и поиску в среднем выполняются за `O(1)`.

**10. В чем основное преимущество `CopyOnWriteArrayList`?**
- `CopyOnWriteArrayList` используется для многопоточных сред, где больше операций чтения, чем записи. При каждом изменении (например, добавление или удаление) создается новая копия списка, что делает операции чтения потокобезопасными без необходимости блокировок. Это идеально подходит для сценариев, где важна быстрая операция чтения и редко происходят изменения.

**11. В чем разница между HashMap и LinkedHashMap?**
**`HashMap`** и **`LinkedHashMap`** — оба представляют собой реализации интерфейса `Map` в Java, но они имеют ряд ключевых отличий в способе хранения данных и их поведении:

<details>
  <summary>1. Порядок хранения элементов</summary>

   - **`HashMap`** не гарантирует никакого порядка элементов. Порядок может меняться в зависимости от операций вставки и удаления, и вы не можете быть уверены, что элементы будут извлекаться в том порядке, в котором они были добавлены.
   - **`LinkedHashMap`** сохраняет **порядок вставки** элементов, что означает, что элементы будут возвращаться в том порядке, в котором они были добавлены. Также существует возможность настроить `LinkedHashMap` для поддержки порядка доступа (когда последние использованные элементы перемещаются в конец).
</details>

<details>
  <summary>2. Структура хранения</summary>

   - **`HashMap`** использует хэш-таблицу для хранения ключей и значений.
   - **`LinkedHashMap`** наследуется от `HashMap`, но дополнительно использует **двусвязный список**, чтобы поддерживать порядок вставки элементов или порядок доступа (если включен режим LRU — least-recently-used).
</details>

<details>
  <summary>3. Производительность</summary>

   - **`HashMap`** немного быстрее в операциях добавления и удаления, так как не нужно управлять связным списком.
   - **`LinkedHashMap`** несколько медленнее из-за поддержания связанного списка, но все основные операции (вставка, удаление, поиск) выполняются за **`O(1)`**, так же как и в `HashMap`.
</details>

<details>
  <summary>4. Использование для кэша</summary>

   - **`LinkedHashMap`** может быть настроен как **LRU-кэш**, который удаляет самые старые записи при достижении определенного размера. Для этого используется конструктор с параметром `accessOrder`, который при значении `true` включает порядок доступа, перемещая недавно использованные элементы в конец.
</details>

<details>
  <summary>5. Пример</summary>

```java
Map<String, Integer> hashMap = new HashMap<>();
hashMap.put("A", 1);
hashMap.put("B", 2);
hashMap.put("C", 3);
System.out.println(hashMap); // Порядок не гарантирован, например: {B=2, A=1, C=3}

Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
linkedHashMap.put("A", 1);
linkedHashMap.put("B", 2);
linkedHashMap.put("C", 3);
System.out.println(linkedHashMap); // Порядок сохраняется: {A=1, B=2, C=3}
```
</details>

#### Итог:
- **`HashMap`** быстрее, если порядок не важен.
- **`LinkedHashMap`** используется, когда важно сохранить порядок вставки или использовать структуру в качестве кэша с поддержкой LRU.

### Алгоритмы сортировки

**1. Когда `QuickSort` эффективнее `MergeSort`?**
- `QuickSort` эффективнее, когда данные хорошо распределены, и память ограничена, так как он использует в среднем `O(log n)` дополнительной памяти, в то время как `MergeSort` требует `O(n)` дополнительной памяти для слияния массивов. Также `QuickSort` имеет лучшие средние и реальные показатели на небольших наборах данных из-за меньших константных накладных расходов.

**2. Когда `MergeSort` предпочтительнее `QuickSort`?**
- `MergeSort` предпочтителен, когда необходима стабильная сортировка (когда одинаковые элементы должны сохранять свой исходный порядок). Также `MergeSort` лучше работает на данных, которые поступают в потоковом виде, или на структурах данных, которые тяжело модифицировать на месте (например, при работе с связанными списками).

**3. В чем преимущества `MergeSort` по сравнению с `QuickSort`?**
- `MergeSort` является стабильным алгоритмом, что означает сохранение исходного порядка одинаковых элементов, в то время как `QuickSort` не гарантирует этого. Кроме того, `MergeSort` всегда имеет временную сложность `O(n log n)`, тогда как у `QuickSort` в худшем случае временная сложность может быть `O(n²)`.

**4. Какая временная сложность алгоритма сортировки вставками (Insertion Sort)?**
- В худшем и среднем случае временная сложность сортировки вставками — `O(n²)`. Однако в лучшем случае, когда массив уже отсортирован или почти отсортирован, сложность может быть `O(n)`, что делает его эффективным для небольших или частично отсортированных наборов данных.

### Структуры данных

**1. В чем разница между стеком и очередью?**
- **Стек** (stack) — это структура данных, работающая по принципу LIFO (Last In, First Out). Элементы добавляются и удаляются только с одного конца стека — вершины.
- **Очередь** (queue) — это структура данных, работающая по принципу FIFO (First In, First Out). Элементы добавляются в конец очереди и удаляются с начала.

**2. Чем отличается массив от связного списка?**
- **Массив** (array) предоставляет быстрый доступ к элементам по индексу (**`O(1)`**), но имеет фиксированный размер. Добавление или удаление элементов требует копирования данных, что может занять **`O(n)`**.
- **Связный список** (linked list) позволяет быстро добавлять и удалять элементы в начале или в конце списка (**`O(1)`** для двусвязного списка), но для доступа к элементу требуется проход по всему списку (**`O(n)`**).

**3. Какова основная разница между `HashMap` и `TreeMap`?**
- **`HashMap`** обеспечивает доступ к элементам за **`O(1)`** в среднем, но не гарантирует порядок элементов.
- **`TreeMap`** поддерживает сортировку по ключам и имеет все операции с временной сложностью **`O(log n)`**, так как основан на сбалансированном бинарном дереве (обычно красно-черное дерево).
