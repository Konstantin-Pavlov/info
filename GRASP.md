**GRASP** (General Responsibility Assignment Software Patterns) — это набор **принципов проектирования** (а не шаблонов проектирования в классическом смысле, как например, паттерны GoF), которые помогают принимать обоснованные решения при распределении обязанностей между классами и объектами в объектно-ориентированном дизайне. Впервые они были представлены Крейгом Ларманом в его книге *"Applying UML and Patterns"*. Эти принципы помогают создавать гибкие, легко поддерживаемые системы, следуя лучшим практикам ООП.

### Основные GRASP-принципы

#### 1. **Information Expert (Информационный эксперт)**

Этот принцип гласит, что ответственность должна быть возложена на тот класс, который обладает необходимыми данными для выполнения задачи.

**Пример**: 
- Допустим, у нас есть класс `Order`, который должен вычислить общую стоимость заказа. Этот класс знает о своих элементах (`OrderItems`), и поэтому именно он должен реализовать метод `calculateTotal()`, так как обладает всей необходимой информацией.

#### 2. **Creator (Создатель)**

Этот принцип определяет, какой класс должен быть ответственным за создание объектов другого класса. Класс A должен создавать объекты класса B, если:
- A агрегирует объекты B.
- A содержит объекты B.
- A использует объекты B.
- A обладает данными, необходимыми для инициализации объектов B.

**Пример**: 
- Класс `Order` может быть ответственным за создание объектов `OrderItem`, так как он содержит и использует эти объекты.

#### 3. **Controller (Контроллер)**

Контроллер — это объект, который обрабатывает входные действия от пользователя (обычно через UI) и координирует выполнение действий между другими объектами. Это может быть интерфейсный контроллер (например, в MVC) или фасадный контроллер для системы.

**Пример**: 
- Контроллер в системе электронной коммерции может управлять процессом обработки заказа, принимая запросы от пользователя (например, добавление товаров в корзину или завершение покупки) и координируя взаимодействие между объектами `Order`, `Payment` и `Customer`.

#### 4. **Low Coupling (Низкая связанность)**

Низкая связанность подразумевает, что классы должны иметь минимальные зависимости от других классов. Это помогает создать гибкую и легко поддерживаемую систему, так как изменения в одном классе минимально затрагивают другие классы.

**Пример**: 
- Класс `Order` не должен напрямую зависеть от класса базы данных. Вместо этого можно использовать слой репозиториев или интерфейсы, чтобы минимизировать зависимость.

#### 5. **High Cohesion (Высокая согласованность)**

Высокая согласованность означает, что класс должен быть сфокусирован на выполнении одной конкретной задачи, а не множества разнородных. Классы с высокой согласованностью легче понять, поддерживать и изменять.

**Пример**: 
- Если класс `Order` занимается как вычислением стоимости заказа, так и отправкой писем с подтверждением, лучше разделить эти обязанности на два класса: один для работы с заказом, другой — для уведомлений.

#### 6. **Polymorphism (Полиморфизм)**

Этот принцип говорит о том, что если необходимо сделать выбор между альтернативными или взаимозаменяемыми действиями, их следует реализовывать с использованием полиморфизма. Вместо того чтобы использовать условные конструкции (`if`, `switch`) для выбора поведения, можно задействовать наследование и интерфейсы.

**Пример**: 
- Вместо того чтобы в классе `PaymentProcessor` проверять, какой тип оплаты используется (кредитная карта или PayPal), можно создать абстрактный класс или интерфейс `PaymentMethod` с методами `processPayment()`, и реализовать конкретные классы для каждого способа оплаты.

#### 7. **Pure Fabrication (Чистая фабрикация)**

Если ни один из классов системы не является очевидным кандидатом для размещения определённой логики, можно создать новый класс, который не отражает реальные предметы предметной области, но служит для лучшего структурирования кода и разделения обязанностей.

**Пример**: 
- В системе может появиться класс `EmailService`, который отвечает только за отправку писем. Это класс, созданный искусственно, так как он не отражает сущность бизнес-логики, но помогает снизить связанность и повысить согласованность.

#### 8. **Indirection (Косвенность)**

Косвенность — это принцип, который гласит, что для уменьшения зависимости между двумя объектами можно использовать промежуточный объект (слой абстракции), который будет координировать взаимодействие. Это помогает добиться более гибкой и легко модифицируемой системы.

**Пример**: 
- Использование шаблона "Фасад" или "Прокси", где один класс выполняет функцию посредника между клиентом и реальной системой, уменьшая зависимость.

#### 9. **Protected Variations (Защищенные вариации)**

Этот принцип подразумевает, что система должна быть защищена от изменения поведения путем использования абстракций, интерфейсов и полиморфизма. Это позволяет изменять реализацию без влияния на других пользователей системы.

**Пример**: 
- В приложении можно использовать интерфейсы для взаимодействия с внешними API, чтобы в случае необходимости можно было заменить одну реализацию (например, платёжную систему) на другую, не меняя логику системы.

### Заключение
GRASP-принципы предоставляют набор лучших практик для проектирования классов и их взаимодействий, помогая разработчикам создавать гибкие, легко модифицируемые и поддерживаемые системы. Они могут быть применены как в простых, так и в сложных проектах для улучшения качества архитектуры приложения.
