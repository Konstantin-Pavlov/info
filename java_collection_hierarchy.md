![image](https://github.com/user-attachments/assets/54e3e1c4-fdad-4961-8ec3-0018d4d81e1d)

В Java коллекции организованы в иерархию интерфейсов и классов, которые предоставляют различные структуры данных для хранения, обработки и манипуляции объектами. Вся иерархия коллекций начинается с интерфейса `Collection`, а также других базовых интерфейсов. Рассмотрим иерархию Java коллекций и особенности каждой структуры.

### 1. **Иерархия коллекций**

#### a) `Collection` — основной интерфейс:
- Он находится на вершине иерархии коллекций и представляет собой группу объектов, которые можно манипулировать как целое.
- От него наследуются три основные ветви: `List`, `Set`, и `Queue`.

#### b) **Интерфейсы `List`, `Set`, `Queue`, `Map`**
- **`List`** — коллекция с упорядоченными элементами, поддерживает индексацию.
- **`Set`** — коллекция, которая не допускает дубликатов.
- **`Queue`** — коллекция, основанная на концепции очереди, обычно поддерживает добавление в конец и удаление из начала.
- **`Map`** — коллекция, которая хранит пары "ключ-значение" и не является частью `Collection`.

#### c) **Основные реализации коллекций**:
- **`ArrayList`**, **`LinkedList`** (реализуют `List`)
- **`HashSet`**, **`TreeSet`** (реализуют `Set`)
- **`PriorityQueue`**, **`ArrayDeque`** (реализуют `Queue`)
- **`HashMap`**, **`TreeMap`** (реализуют `Map`)

### 2. **Детальное устройство коллекций**

#### a) **List**
1. **`ArrayList`**:
   - Реализован на основе массива динамического размера.
   - Быстрый доступ по индексу (O(1)).
   - Вставка/удаление в середину или начало — медленные операции (O(n)), так как элементы смещаются.
   - Основной массив автоматически увеличивается в размере при достижении предела.
   - Применение: когда важен быстрый доступ к элементам по индексу.

2. **`LinkedList`**:
   - Двунаправленный связный список.
   - Быстрое добавление/удаление в начало и конец (O(1)).
   - Медленный доступ по индексу (O(n)), так как требуется обход списка.
   - Применение: когда важна производительность операций добавления/удаления в середину.

#### b) **Set**
1. **`HashSet`**:
   - Основан на **хеш-таблице**. Элементы не упорядочены.
   - Добавление, удаление и проверка на наличие элемента за время O(1) в среднем.
   - Не допускает дубликатов, каждый элемент должен быть уникален.
   - Требует определения метода `hashCode()` и `equals()`.
   - Применение: для быстрого поиска уникальных элементов.

2. **`LinkedHashSet`**:
   - Наследует от `HashSet`, но также поддерживает порядок вставки элементов.
   - Немного медленнее `HashSet` из-за дополнительной структуры для хранения порядка.
   - Применение: если нужно сохранить порядок вставки без дубликатов.

3. **`TreeSet`**:
   - Реализован на основе **красно-черного дерева**. Элементы автоматически сортируются.
   - Время операций добавления, удаления и поиска — O(log n).
   - Требует реализации интерфейса `Comparable` или передачи объекта `Comparator`.
   - Применение: если требуется поддерживать сортированный набор элементов.

#### c) **Queue**
1. **`PriorityQueue`**:
   - Реализована на основе **минимальной кучи** (binary heap).
   - Элементы извлекаются в порядке приоритета (обычно наименьший элемент извлекается первым).
   - Время вставки и удаления элемента — O(log n).
   - Применение: для задач, где нужно эффективно управлять элементами по приоритету (например, для задач со сроком выполнения).

2. **`ArrayDeque`**:
   - Реализована на основе динамического массива.
   - Двусторонняя очередь с быстрой вставкой/удалением элементов в начало и конец (O(1)).
   - Нет ограничений на размер.
   - Применение: для очередей или стеков, когда важна производительность операций вставки/удаления с обеих сторон.

#### d) **Map**
1. **`HashMap`**:
   - Основан на **хеш-таблице**. Хранит пары "ключ-значение".
   - Время доступа, добавления и удаления по ключу — O(1) в среднем.
   - Не гарантирует порядка ключей.
   - Требует определения метода `hashCode()` и `equals()` для ключей.
   - Применение: для быстрого поиска данных по ключу.

2. **`LinkedHashMap`**:
   - Наследует от `HashMap`, но сохраняет порядок вставки.
   - Используется, когда важен порядок добавления элементов.
   - Применение: когда нужно быстрое выполнение операций и сохранение порядка ключей.

3. **`TreeMap`**:
   - Реализован на основе **красно-черного дерева**.
   - Ключи сортируются автоматически.
   - Время доступа, вставки и удаления — O(log n).
   - Требует реализации интерфейса `Comparable` для ключей.
   - Применение: когда нужно поддерживать сортированный набор ключей.

### 3. **Сводка**

- **`List`** — для упорядоченных коллекций с доступом по индексу. `ArrayList` быстрый для доступа по индексу, но медленный для вставок, в то время как `LinkedList` лучше для частых вставок/удалений.
- **`Set`** — для уникальных элементов. `HashSet` — лучший выбор для быстрого поиска, `TreeSet` — для сортировки.
- **`Queue`** — для работы с элементами по очереди. `PriorityQueue` поддерживает приоритетную сортировку, а `ArrayDeque` хорош для двусторонней очереди.
- **`Map`** — для пар ключ-значение. `HashMap` предоставляет быструю работу с ключами, `TreeMap` — если требуется поддерживать сортировку ключей.

### 4. **Пример использования разных коллекций**

```java
import java.util.*;

public class CollectionExample {
    public static void main(String[] args) {
        // List Example
        List<String> arrayList = new ArrayList<>();
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add("Cherry");
        System.out.println("ArrayList: " + arrayList);

        // Set Example
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Dog");
        hashSet.add("Elephant");
        hashSet.add("Dog"); // Duplicate, won't be added
        System.out.println("HashSet: " + hashSet);

        // Queue Example
        Queue<Integer> priorityQueue = new PriorityQueue<>();
        priorityQueue.add(3);
        priorityQueue.add(1);
        priorityQueue.add(2);
        System.out.println("PriorityQueue: " + priorityQueue);

        // Map Example
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("One", 1);
        hashMap.put("Two", 2);
        hashMap.put("Three", 3);
        System.out.println("HashMap: " + hashMap);
    }
}
```

### Заключение
Иерархия Java коллекций представляет собой мощный инструмент для работы с различными типами данных. Каждый тип коллекции имеет свои особенности и подходит для разных задач.
